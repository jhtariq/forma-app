import { NextRequest, NextResponse } from 'next/server'
import { createServerSupabaseClient, createServiceRoleClient } from '@/lib/supabase/server'
import { jsPDF } from 'jspdf'
import autoTable from 'jspdf-autotable'
import JSZip from 'jszip'

/* eslint-disable @typescript-eslint/no-explicit-any */

export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ projectId: string }> }
) {
  const { projectId } = await params
  const body = await request.json()
  const selectedTags: string[] = body.selectedTags ?? []

  try {
    const supabase = await createServerSupabaseClient()
    const serviceClient = await createServiceRoleClient()

    // Get current user
    const { data: { user: authUser } } = await supabase.auth.getUser()
    if (!authUser) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get app user
    const { data: appUser } = await serviceClient
      .from('app_users')
      .select('*')
      .eq('id', authUser.id)
      .single()
    if (!appUser) {
      return NextResponse.json({ error: 'User not found' }, { status: 404 })
    }

    // Get project
    const { data: project } = await serviceClient
      .from('projects')
      .select('*, facilities(name)')
      .eq('id', projectId)
      .single()
    if (!project) {
      return NextResponse.json({ error: 'Project not found' }, { status: 404 })
    }

    // Get latest approved spec revision
    const { data: specApproval } = await serviceClient
      .from('approval_requests')
      .select('spec_revision_id')
      .eq('project_id', projectId)
      .eq('entity_type', 'spec')
      .eq('status', 'approved')
      .order('requested_at', { ascending: false })
      .limit(1)
    let specFields: Record<string, string> = {}
    let specVersion = 0
    if (specApproval?.[0]?.spec_revision_id) {
      const { data: specRev } = await serviceClient
        .from('spec_revisions')
        .select('*')
        .eq('id', specApproval[0].spec_revision_id)
        .single()
      if (specRev) {
        specFields = specRev.fields_json as Record<string, string>
        specVersion = specRev.version_int
      }
    }

    // Get latest approved bom revision
    const { data: bomApproval } = await serviceClient
      .from('approval_requests')
      .select('bom_revision_id')
      .eq('project_id', projectId)
      .eq('entity_type', 'bom')
      .eq('status', 'approved')
      .order('requested_at', { ascending: false })
      .limit(1)
    let bomRows: Array<Record<string, unknown>> = []
    let bomVersion = 0
    if (bomApproval?.[0]?.bom_revision_id) {
      const { data: bomRev } = await serviceClient
        .from('bom_revisions')
        .select('*')
        .eq('id', bomApproval[0].bom_revision_id)
        .single()
      if (bomRev) {
        bomVersion = bomRev.version_int
        const { data: rows } = await serviceClient
          .from('bom_rows')
          .select('*')
          .eq('bom_revision_id', bomRev.id)
          .order('line_no')
        bomRows = rows ?? []
      }
    }

    // Get approval history
    const { data: approvalHistory } = await serviceClient
      .from('approval_requests')
      .select(`
        *,
        requester:app_users!approval_requests_requested_by_fkey(name),
        decisions:approval_decisions(*, user:app_users(name))
      `)
      .eq('project_id', projectId)
      .order('requested_at', { ascending: false })
    // Get documents matching selected tags
    const { data: documents } = await serviceClient
      .from('documents')
      .select('*')
      .eq('project_id', projectId)
    const filteredDocs =
      documents?.filter((d: any) =>
        d.tags?.some((t: string) => selectedTags.includes(t))
      ) ?? []

    // ---- Generate PDF Summary ----
    const doc = new jsPDF()
    const pageWidth = doc.internal.pageSize.getWidth()

    // Cover page
    doc.setFontSize(24)
    doc.setTextColor(40, 40, 40)
    doc.text('FORMA', pageWidth / 2, 40, { align: 'center' })
    doc.setFontSize(12)
    doc.text('Audit / Compliance Pack', pageWidth / 2, 50, { align: 'center' })

    doc.setFontSize(10)
    doc.setTextColor(80, 80, 80)
    const coverInfo = [
      ['Project', project.name],
      ['Customer', project.customer || 'N/A'],
      ['Facility', (project.facilities as { name: string })?.name || 'N/A'],
      ['Due Date', project.due_date || 'N/A'],
      ['Status', project.status],
      ['Generated At', new Date().toISOString()],
      ['Generated By', appUser.name],
    ]

    let y = 70
    coverInfo.forEach(([label, value]) => {
      doc.setFont('helvetica', 'bold')
      doc.text(`${label}:`, 20, y)
      doc.setFont('helvetica', 'normal')
      doc.text(String(value), 70, y)
      y += 8
    })

    // Spec section
    if (Object.keys(specFields).length > 0) {
      doc.addPage()
      doc.setFontSize(16)
      doc.setTextColor(40, 40, 40)
      doc.text(`Approved Spec (v${specVersion})`, 20, 20)

      doc.setFontSize(9)
      const specRows = Object.entries(specFields)
        .filter(([, v]) => v)
        .map(([k, v]) => [k.replace(/_/g, ' '), String(v)])

      autoTable(doc, {
        startY: 30,
        head: [['Field', 'Value']],
        body: specRows,
        theme: 'striped',
        headStyles: { fillColor: [60, 60, 60] },
        styles: { fontSize: 9, cellPadding: 3 },
      })
    }

    // BOM section
    if (bomRows.length > 0) {
      doc.addPage()
      doc.setFontSize(16)
      doc.setTextColor(40, 40, 40)
      doc.text(`Approved BOM (v${bomVersion})`, 20, 20)

      const bomTableRows = bomRows.map((r) => [
        String(r.line_no),
        String(r.material),
        String(r.supplier),
        String(r.qty),
        String(r.unit),
        `${r.currency || ''} ${r.unit_cost}`,
        String(r.notes || ''),
      ])

      autoTable(doc, {
        startY: 30,
        head: [['#', 'Material', 'Supplier', 'Qty', 'Unit', 'Cost', 'Notes']],
        body: bomTableRows,
        theme: 'striped',
        headStyles: { fillColor: [60, 60, 60] },
        styles: { fontSize: 8, cellPadding: 2 },
      })
    }

    // Included documents
    if (filteredDocs.length > 0) {
      doc.addPage()
      doc.setFontSize(16)
      doc.text('Included Documents', 20, 20)

      const docRows = filteredDocs.map((d: any) => [
        d.filename,
        (d.tags ?? []).join(', '),
      ])

      autoTable(doc, {
        startY: 30,
        head: [['Filename', 'Tags']],
        body: docRows,
        theme: 'striped',
        headStyles: { fillColor: [60, 60, 60] },
        styles: { fontSize: 9 },
      })
    }

    // Approval history
    if (approvalHistory && approvalHistory.length > 0) {
      doc.addPage()
      doc.setFontSize(16)
      doc.text('Approval History', 20, 20)

      const approvalRows = approvalHistory.map((a: any) => {
        const decisions = (a.decisions as Array<{
          decision: string
          user?: { name: string }
          decided_at: string
          comment?: string
        }>) ?? []
        const decision = decisions[0]

        return [
          a.entity_type.toUpperCase(),
          a.status,
          (a.requester as { name: string })?.name || '',
          new Date(a.requested_at).toLocaleDateString(),
          decision?.user?.name || 'Pending',
          decision ? new Date(decision.decided_at).toLocaleDateString() : '',
          decision?.comment || '',
        ]
      })

      autoTable(doc, {
        startY: 30,
        head: [['Type', 'Status', 'Requested By', 'Date', 'Decided By', 'Decision Date', 'Comment']],
        body: approvalRows,
        theme: 'striped',
        headStyles: { fillColor: [60, 60, 60] },
        styles: { fontSize: 8, cellPadding: 2 },
      })
    }

    // ---- Build ZIP ----
    const zip = new JSZip()
    const pdfBuffer = Buffer.from(doc.output('arraybuffer'))
    zip.file('Summary.pdf', pdfBuffer)

    // Add document files
    for (const d of filteredDocs as any[]) {
      try {
        const { data: fileData } = await serviceClient.storage
          .from('project-documents')
          .download(d.storage_path)

        if (fileData) {
          const arrayBuffer = await fileData.arrayBuffer()
          zip.file(`documents/${d.filename}`, arrayBuffer)
        }
      } catch {
        // Skip files that fail to download
      }
    }

    const zipBuffer = await zip.generateAsync({ type: 'nodebuffer' })

    // Upload ZIP to storage
    const exportId = crypto.randomUUID()
    const exportPath = `${appUser.org_id}/${projectId}/${exportId}/export-pack.zip`

    await serviceClient.storage
      .from('project-exports')
      .upload(exportPath, zipBuffer, {
        contentType: 'application/zip',
      })

    // Create export record
    await serviceClient.from('export_packs').insert({
      id: exportId,
      project_id: projectId,
      spec_revision_id: specApproval?.[0]?.spec_revision_id ?? null,
      bom_revision_id: bomApproval?.[0]?.bom_revision_id ?? null,
      included_document_ids: filteredDocs.map((d: any) => d.id),
      storage_path: exportPath,
      generated_by: appUser.id,
    })

    // Log audit event
    await serviceClient.from('audit_events').insert({
      project_id: projectId,
      actor_user_id: appUser.id,
      action: 'export_generated',
      entity_type: 'export_pack',
      entity_id: exportId,
      metadata_json: {
        document_count: filteredDocs.length,
      },
    })

    // Auto-transition to Exported
    await serviceClient
      .from('projects')
      .update({ status: 'Exported', updated_at: new Date().toISOString() })
      .eq('id', projectId)

    // Get download URL
    const { data: signedUrl } = await serviceClient.storage
      .from('project-exports')
      .createSignedUrl(exportPath, 3600, { download: true })

    return NextResponse.json({
      exportId,
      downloadUrl: signedUrl?.signedUrl,
    })
  } catch (err) {
    console.error('Export error:', err)
    return NextResponse.json(
      { error: 'Failed to generate export' },
      { status: 500 }
    )
  }
}
